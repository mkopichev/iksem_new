/*****************************************************
Chip type               : ATmega128A
Program type            : Application
AVR Core Clock frequency: 11,059200 MHz
Memory model            : Small
External RAM size       : 0
Data Stack size         : 1024
*****************************************************/

#include <mega128a.h>
#include <delay.h>
// I2C Bus functions
#include <i2c.h>
// Standard Input/Output functions                                      
#include <stdio.h>


#define DDR_SPI DDRB
#define PORT_SPI PORTB
#define SS 0

#define ADC_VREF_TYPE 0xC0
#ifndef UDRE
#define UDRE 5
#endif
#define DATA_REGISTER_EMPTY (1<<UDRE)
#define AD7799_DDRDY PINB.3




#define AVERAGE_NUMBER 15

#define FIXWEIGHT //закоментить отрубить фиксированный вес
#define SPEEDFILTER //закоментить отрубить медианный фильтр скорости
#define ADC_FAULT_RESET //закоментить отрубить отрубание телеги при неправильной иниц ADC

//#define ADC_TO_KG//Раскометить для поверки Закоментить чтоб измерять 

#define IKS00  //номер телеги!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          

//Список необходимых изменений
//5)АЦП периодически не инициализируется исправить
//6)Показания аккумулятора фильтрануть ++++++++++++++++++++

//Формула 

//В проге мобилы:
//2)Задание Скольж убрать
//3)Скорость мерять правильно
//4)пароль сделать из файла
//5)выводить код ошибки и саму ошибку


eeprom unsigned char EEP_SETUP_MAS[8];
eeprom unsigned char EEP_CALIBR_MAS[10];



#ifdef IKS01
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CALIBR_MAIN_DATA N01
#define N_string "AT+NAMEIKSEM#01\r\n"
//unsigned int WEIGHT_NULL=7039, LOADCELL_NULL=1807, DELTA_WEIGHT10KG=842, DELTA_LOADCELL10KG=513;
//unsigned int WEIGHT_NULL=7023, LOADCELL_NULL=1900, DELTA_WEIGHT10KG=834, DELTA_LOADCELL10KG=508;
unsigned int WEIGHT_NULL=6752, LOADCELL_NULL=2089, DELTA_WEIGHT10KG=800, DELTA_LOADCELL10KG=475; //march 17 2023 Mishanja
unsigned int R_IK=202, R_TK=333 , ZADANIE_S=15;
unsigned char SETUP_MAS[8]={0,0,0,0,0,0,0,0};
unsigned char CALIBR_MAS[10]={0,0,0,0,0,0,0,0,0,0};
unsigned char DEFAULT_SETUP_MAS[8]={248,202,133,15,1,0,0,(202+133+15+1)/6};
//unsigned char DEFAULT_CALIBR_MAS[10]={249,70,39,18,7,8,42,5,13,(70+39+18+7+8+42+5+13)/8};
//unsigned char DEFAULT_CALIBR_MAS[10]={249,70,23,19,0,8,34,5,8,(70+23+19+0+8+34+5+8)/8};
unsigned char DEFAULT_CALIBR_MAS[10]={249,67,52,20,89,8,0,4,75,(67+52+20+89+8+0+4+75)/8};
int ADC_0_KG=1524,ADC_100_KG=6759; 
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CALIBR_MAIN_DATA N01
#endif

#ifdef IKS02
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CALIBR_MAIN_DATA N02
#define N_string "AT+NAMEIKSEM#02\r\n"
//unsigned int WEIGHT_NULL=6846, LOADCELL_NULL=400, DELTA_WEIGHT10KG=835, DELTA_LOADCELL10KG=495;
//unsigned int WEIGHT_NULL=6914, LOADCELL_NULL=395, DELTA_WEIGHT10KG=863, DELTA_LOADCELL10KG=511;
unsigned int WEIGHT_NULL=6838, LOADCELL_NULL=364, DELTA_WEIGHT10KG=856, DELTA_LOADCELL10KG=516;
unsigned int R_IK=202, R_TK=333 , ZADANIE_S=15;
unsigned char SETUP_MAS[8]={0,0,0,0,0,0,0,0};
unsigned char CALIBR_MAS[10]={0,0,0,0,0,0,0,0,0,0};
unsigned char DEFAULT_SETUP_MAS[8]={248,202,133,15,1,0,0,(202+133+15+1)/6};
//unsigned char DEFAULT_CALIBR_MAS[10]={249,68,46,4,0,8,35,4,95,(68+46+4+0+8+35+4+95)/8};
//unsigned char DEFAULT_CALIBR_MAS[10]={249,69,14,3,95,8,63,5,11,(69+14+3+95+8+63+5+11)/8};
unsigned char DEFAULT_CALIBR_MAS[10]={249,68,38,3,64,8,56,5,16,(68+38+3+64+8+56+5+16)/8};        

unsigned char ADC_0_KG=88,ADC_100_KG=6759;     
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CALIBR_MAIN_DATA N02
#endif

#ifdef IKS03
////!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CALIBR_MAIN_DATA N03
#define N_string "AT+NAMEIKSEM#03\r\n"
//unsigned int WEIGHT_NULL=6944, LOADCELL_NULL=313, DELTA_WEIGHT10KG=825, DELTA_LOADCELL10KG=495;
unsigned int WEIGHT_NULL=7093, LOADCELL_NULL=402, DELTA_WEIGHT10KG=843, DELTA_LOADCELL10KG=500;
unsigned int R_IK=202, R_TK=333 , ZADANIE_S=15;
unsigned char SETUP_MAS[8]={0,0,0,0,0,0,0,0};
unsigned char CALIBR_MAS[10]={0,0,0,0,0,0,0,0,0,0};
unsigned char DEFAULT_SETUP_MAS[8]={248,202,133,15,1,0,0,(202+133+15+1)/6};
//unsigned char DEFAULT_CALIBR_MAS[10]={249,69,44,3,13,8,25,4,95,(69+44+3+13+8+25+4+95)/8};
unsigned char DEFAULT_CALIBR_MAS[10]={249,70,93,4,2,8,43,5,0,(70+93+4+2+8+43+5+0)/8}; 

unsigned char ADC_0_KG=88,ADC_100_KG=6759;  
////!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CALIBR_MAIN_DATA N03
#endif

#ifdef IKS00
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!PCS_WITHOUT_TELEGA
#define N_string "AT+NAMEIKSEM#00\r\n"
unsigned int WEIGHT_NULL=6752, LOADCELL_NULL=2089, DELTA_WEIGHT10KG=800, DELTA_LOADCELL10KG=475; //march 17 2023 Mishanja
unsigned int R_IK=202, R_TK=333 , ZADANIE_S=15;
unsigned char SETUP_MAS[8]={0,0,0,0,0,0,0,0};
unsigned char CALIBR_MAS[10]={0,0,0,0,0,0,0,0,0,0};
unsigned char DEFAULT_SETUP_MAS[8]={248,202,133,15,1,0,0,(202+133+15+1)/6};
unsigned char DEFAULT_CALIBR_MAS[10]={249,67,52,20,89,8,0,4,75,(67+52+20+89+8+0+4+75)/8};
int ADC_0_KG=1524,ADC_100_KG=6759; 
#endif


unsigned flag_transmission=255;
unsigned flag_receive=0,receive_counter=0;

unsigned char SEND_MAS[26]={255,5,55,4,49,6,21,7,50,5,80,75,0,3598/60,3598%60,31,22,1819/60,1819%60,55,24,'N','E',50,0,35};


unsigned char program_cycle_flag=0,program_cycle_counter=0;

unsigned char ovf_IK=0, ovf_TK=0;
unsigned long IK_COUNT[2]={0,0}, TK_COUNT[2]={0,0}, IK_DELTA=0, TK_DELTA=0;
unsigned int IK_SPEED_KM_H=0,TK_SPEED_KM_H=0;
unsigned int IK_SPEED_MAS[3]={0,0,0},TK_SPEED_MAS[3]={0,0,0}; 

unsigned int ADC_BAT=0,ADC_I=0;
unsigned int BAT_SUM=0;
long I_NULL=0;
unsigned char flag_I_NULL=0;
//  unsigned int A_BAT=0,A_I=0;

unsigned char GPS_zap_counter=0,GPS_sim_counter=0,GPS_flag_ready=0;//1-ustanovlen 0-ne ustanovlen
unsigned char GPS_string_name[3]={0,0,0},GPS_flag_gp=0;//0-no 1-1 bukva posle P, 2-2ya, 3-3ya, 4-GGA
unsigned int GPS_shir[4]={1,1,1,1},GPS_dolg[4]={1,1,1,1};//grad min .xxxx  NSWE
unsigned char GPS_solve=0;
unsigned char GPS_ON_COUNTER=0;
unsigned char flag_start=0;
unsigned char measuring_start_counter=0;
int load_cell=0,load_cell_MAS[20];
unsigned char ADC_fault_counter=0;


int PID_I_S=800;


interrupt [EXT_INT7] void ext_int7_isr(void);
interrupt [EXT_INT6] void ext_int6_isr(void);
void init_all(void);
void led_zero(void);
void led_one(void);
void lights(char G, char R, char B);
unsigned int K_BY_KOEFFICIENTS_REAL(unsigned int M);
unsigned int K_BY_KOEFFICIENTS_ASFT(unsigned int M);
void Read_Setup_Calibr(void);
void Control_Sum_Send(void);
void Control_Sum_Calibr(void);
void Control_Sum_Setup(void);
interrupt [TIM1_OVF] void timer1_ovf_isr(void);
void delay(unsigned int d);
void SPI_MasterInit(void);
unsigned char SPI_MasterReceive(void);
void SPI_MasterTransmit(unsigned char x);
void SET_AD7799(void);
unsigned int READ_AD7799(void);
void uart1SendByte(char data);
void uart1SendString(char *str);
void uart1SendArray(unsigned char *array, unsigned char size);
interrupt [USART0_RXC] void usart0_rx_isr(void);
interrupt [USART1_RXC] void usart1_rx_isr(void);
unsigned int read_adc(unsigned char adc_input);
interrupt [TIM2_OVF] void timer2_ovf_isr(void);

void load_from_eeprom(void);
void save_to_eeprom(void);

unsigned int load_cell_filter(void)
{
 unsigned char tmp;
 unsigned long int sum=0;
  
 if(measuring_start_counter<2)
 {
  for(tmp=(AVERAGE_NUMBER-1);tmp>0;tmp--)
  {   
    load_cell_MAS[tmp]=load_cell;
    sum=sum+load_cell;
  } 
 }
 else
 {
  for(tmp=(AVERAGE_NUMBER-1);tmp>0;tmp--)
  {   
    load_cell_MAS[tmp]=load_cell_MAS[tmp-1];
    sum=sum+load_cell_MAS[tmp];
  } 
 } 
 load_cell_MAS[0]=load_cell;
 sum=sum+load_cell;
 sum=sum/AVERAGE_NUMBER;
 return (unsigned int)sum;
}

// Write a character to the USART1 Transmitter
#pragma used+
void putchar1(char c)
{
 while ((UCSR1A & DATA_REGISTER_EMPTY)==0);
  UDR1=c;
}
#pragma used-

//
unsigned int middle(unsigned int d1, unsigned int d2, unsigned int d3)
{
 if(d1>=d2)
 {
  if(d1<=d3) return d1;
  else  
  {
   if(d2>=d3)
    return d2;
   else
    return d3;
  }
 }
 else
 {
  if(d2<=d3) return d2;
  else  
  {
   if(d1>=d3)
    return d1;
   else 
    return d3;
  }
 }
}

void main(void)
{
// Declare your local variables here
unsigned char main_cycle=0,flag_led_direction=0,led_cycle=0;
unsigned int BAT=0;
unsigned int K=0;
unsigned int TMP,TMPL;

int M=0;
int I=0;
unsigned int TIME_OUT=10*60*30;

Control_Sum_Calibr();
Control_Sum_Setup();
load_from_eeprom();
Read_Setup_Calibr();




init_all();
// I2C Port: PORTD
// I2C SDA bit: 1
// I2C SCL bit: 0
// Bit Rate: 100 kHz
i2c_init();

SPI_MasterInit();

// Global enable interrupts


PORTC.0 = 1;//iksem - on

//PORTC.1 = 1;//fonar on


delay_ms(100);
SET_AD7799();
delay_ms(100);
SET_AD7799();
delay_ms(100);
uart1SendString(N_string);//Set BLUETOOTH NAME
#asm("sei");

while (1)
    { 
     /*  
      program_cycle_flag=0;
      while(program_cycle_flag!=1)
      {}
      program_cycle_flag=0;
     */ 
     
      #ifdef SPEEDFILTER
      TMP=middle(TK_SPEED_MAS[0],TK_SPEED_MAS[1],TK_SPEED_MAS[2]);
      SEND_MAS[1]= TMP/100;
      SEND_MAS[2]= TMP%100;
      TMP=middle(IK_SPEED_MAS[0],IK_SPEED_MAS[1],IK_SPEED_MAS[2]);
      SEND_MAS[3]= TMP/100;
      SEND_MAS[4]= TMP%100;
      #else 
      SEND_MAS[1]= TK_SPEED_KM_H/100;
      SEND_MAS[2]= TK_SPEED_KM_H%100; 
      SEND_MAS[3]= IK_SPEED_KM_H/100;
      SEND_MAS[4]= IK_SPEED_KM_H%100;
      #endif
                                           
       if(flag_start==1)
       {
        TIME_OUT=10*60*30;
        
       // measuring_start_counter++;
       }//30 min
       else
       {    
        if(TIME_OUT==0)
         PORTC.0 = 0;//iksem - off
        else
         TIME_OUT--;
       }                             
       
      
      while(AD7799_DDRDY==0) //!DDRDY
      {}  
               
      #ifdef ADC_FAULT_RESET
       TMPL=TCNT3L;//read low first
       TMP=TCNT3H;
       TMP=(TMP<<8)+TMPL;     
       if((TMP<(1080-250))||(TMP>(1080+250)))
       {  
        if(ADC_fault_counter>5)
        {
         PORTC.0 = 0;//iksem - off
        } 
        else
        { 
         ADC_fault_counter++;
        }  
       }   
       else
       {
        ADC_fault_counter=0;
        PORTC.0 = 1;//iksem - on
       }    
       TCNT3H=0;//write high first
       TCNT3L=0;
      #endif
       
      delay_ms(1);
      load_cell=READ_AD7799();
      delay_ms(1);                          
                              
     //M----------------------------------------------
     #ifdef ADC_TO_KG
     load_cell=load_cell-ADC_0_KG;
     load_cell=(int)(((long int)load_cell*10000)/(long int)ADC_100_KG);
     if(load_cell<0)
     {load_cell=0;}
     #endif
     //load_cell=88 - 0kg
     //load_cell=835 - 11,1kg 
     // 1 adc = 0,01486 kg 
     

      M=load_cell_filter(); 
      if(M<0)
      M=0;
      if(M>10000)
      M=10000;       
      if(flag_start==0)
      {
       measuring_start_counter=0;
      }          
      else
      { 
       if(measuring_start_counter<30)
        {measuring_start_counter++;}
      }  
      
      SEND_MAS[7]=M/100;
      SEND_MAS[8]=M%100;
      //---------------------------------------------
      
          
     //KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
      if(ZADANIE_S==15)
       K=K_BY_KOEFFICIENTS_ASFT(M);
      else 
       K=K_BY_KOEFFICIENTS_REAL(M); 
                                                   
      SEND_MAS[5]=K/100;
      SEND_MAS[6]=K%100;
      
     //KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
      
     ADC_BAT=read_adc(0);
     ADC_I=read_adc(1);//0.021В датчика = 1А = 2.1*4 = 8.4 АЦП (1024 = 2.56в)
     BAT_SUM=(BAT_SUM*9)/10+ADC_BAT;
     ADC_BAT=BAT_SUM/10;
     if(flag_I_NULL<10)
     {
      I_NULL=I_NULL+ADC_I;
           
      if(flag_I_NULL==9)
      I_NULL=I_NULL/10;
    
      flag_I_NULL++;
     }  
     //BATTERY LEVEL--------------------------------------------------------  
      BAT=ADC_BAT;//163*4-100%(12.7) 150*4-0%(11.7)
             
     // if(ADC_I>=(252*4))
     //  I=0;
     // else                                                                                              
       
      
      
      if(BAT<=610)
       {
        SEND_MAS[23]=0;
       } 
       else
       {
        if(BAT>=660)
         SEND_MAS[23]=100;
        else
         SEND_MAS[23]=(unsigned char)((BAT-610)*2);
       }        
     //--------------------------------------------------------------------
     
     I=ADC_I;                   
     I=(int)(((long)(I_NULL-I)*100)/84);//0.021В датчика = 1А = 2.1*4 = 8.4 АЦП (1024 = 2.56в) 2.52v=0   
     if(I<0)
     I=0;
     
        
      SEND_MAS[9]=I/100;
      SEND_MAS[10]=I%100;        
      
     
    //Контрольная сумма----------------------
     Control_Sum_Send();              
    //---------------------------------------
      if(flag_transmission==255)
      {  
       uart1SendArray(SEND_MAS,26);
      }                    
      else
      {                     
       if(flag_transmission==248)
       {
        uart1SendArray(SETUP_MAS,8);
        flag_transmission=255;
       } 
       if(flag_transmission==249)
       {  
        uart1SendArray(CALIBR_MAS,10);
        flag_transmission=255;
       }
      }
                     
      
      #asm("cli")
      lights(252-led_cycle*28,led_cycle*28,252-led_cycle*28);  
      #asm("sei")
      
      if(led_cycle==9)
      flag_led_direction=1;
      
      if(led_cycle==0)
      flag_led_direction=0;
      
      if(flag_led_direction==0)      
      led_cycle++;
      else
      led_cycle--;
      
      if(main_cycle>=9)
      main_cycle=0;
      else
      main_cycle++;   
      
                                                
    }
}


//SPEED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//SPEED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//SPEED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// External Interrupt 6 service routine
interrupt [EXT_INT6] void ext_int6_isr(void) //TK_SPEED
{
 unsigned char H,L;
 TK_COUNT[0]=TK_COUNT[1];
 L=TCNT1L;
 H=TCNT1H;
 TK_COUNT[1]=(unsigned long)H*256+(unsigned long)L;
 if(ovf_TK>0)
 {
  if(ovf_TK==2)
  {
   TK_DELTA=0;
   TK_COUNT[0]=0;
   TK_COUNT[1]=0;
  }
  else
  {
   TK_DELTA=(65536-TK_COUNT[0])+TK_COUNT[1];
  } 
  ovf_TK=0;
 }
 else
 {
  TK_DELTA=TK_COUNT[1]-TK_COUNT[0];
 }
}


// External Interrupt 7 service routine
interrupt [EXT_INT7] void ext_int7_isr(void) //IK_SPEED
{
 unsigned char H,L;
 IK_COUNT[0]=IK_COUNT[1];
 L=TCNT1L;
 H=TCNT1H;
 IK_COUNT[1]=(unsigned long)H*256+(unsigned long)L;
 if(ovf_IK>0)
 {
  if(ovf_IK==2)
  {
   IK_DELTA=0;
   IK_COUNT[0]=0;
   IK_COUNT[1]=0;
  }
  else
  {
   IK_DELTA=(65536-IK_COUNT[0])+IK_COUNT[1];
  } 
  ovf_IK=0;
 }
 else
 {
  IK_DELTA=IK_COUNT[1]-IK_COUNT[0];
 }  
}





void init_all(void)
{

 // Port B initialization
 DDRB.4=1;
 DDRB.6=1;    
 
 // Port C initialization
 // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=Out Func0=Out 
 // State7=T State6=T State5=T State4=T State3=T State2=T State1=0 State0=0 
 PORTC=0x00;
 DDRC=0x03;
 PORTC.2=0;//GPS on 
 DDRC.2=1;
 
 
 // Timer/Counter 0 initialization
 // Clock source: System Clock
 // Clock value: 1382,400 kHz
 // Mode: Phase correct PWM top=0xFF
 // OC0 output: Inverted PWM
 ASSR=0x00;
 TCCR0=0x72;
 TCNT0=0x00;
 OCR0=255;
 
 // Timer/Counter 1 initialization
// Clock source: System Clock
// Clock value: 172,800 kHz
// Mode: Normal top=FFFFh
// OC1A output: Discon.
// OC1B output: Discon.
// OC1C output: Discon.
// Noise Canceler: Off
// Input Capture on Falling Edge
// Timer 1 Overflow Interrupt: On
// Input Capture Interrupt: Off
// Compare A Match Interrupt: Off
// Compare B Match Interrupt: Off
// Compare C Match Interrupt: Off
TCCR1A=0x00;
TCCR1B=0x03;
TCNT1H=0x00;
TCNT1L=0x00;
ICR1H=0x00;
ICR1L=0x00;
OCR1AH=0x00;
OCR1AL=0x00;
OCR1BH=0x00;
OCR1BL=0x00;
OCR1CH=0x00;
OCR1CL=0x00;
 
 
 
 // Timer/Counter 2 initialization
 // Clock source: System Clock
 // Clock value: 10,800 kHz
 // Mode: Normal top=0xFF
 // OC2 output: Disconnected
 TCCR2=0x05;
 TCNT2=0x00;
 OCR2=0x00;


// Timer/Counter 3 initialization
// Clock source: System Clock
// Clock value: 10,800 kHz
// Mode: Normal top=0xFFFF
// OC3A output: Discon.
// OC3B output: Discon.
// OC3C output: Discon.
// Noise Canceler: Off
// Input Capture on Falling Edge
// Timer3 Overflow Interrupt: Off
// Input Capture Interrupt: Off
// Compare A Match Interrupt: Off
// Compare B Match Interrupt: Off
// Compare C Match Interrupt: Off
TCCR3A=0x00;
TCCR3B=0x05;
TCNT3H=0x00;
TCNT3L=0x00;
ICR3H=0x00;
ICR3L=0x00;
OCR3AH=0x00;
OCR3AL=0x00;
OCR3BH=0x00;
OCR3BL=0x00;
OCR3CH=0x00;
OCR3CL=0x00;


 // Timer(s)/Counter(s) Interrupt(s) initialization
 TIMSK=0x44;

 ETIMSK=0x00;

 // External Interrupt(s) initialization
 // INT0: Off
 // INT1: Off
 // INT2: Off
 // INT3: Off
 // INT4: Off
 // INT5: Off
 // INT6: On
 // INT6 Mode: Rising Edge
 // INT7: On
 // INT7 Mode: Rising Edge
 EICRA=0x00;
 EICRB=0xF0;
 EIMSK=0xC0;
 EIFR=0xC0;

 // USART0 initialization
 // Communication Parameters: 8 Data, 1 Stop, No Parity
 // USART0 Receiver: On
 // USART0 Transmitter: On
 // USART0 Mode: Asynchronous
 // USART0 Baud Rate: 9600
 UCSR0A=0x00;
 UCSR0B=0x98;
 UCSR0C=0x06;
 UBRR0H=0x00;
 UBRR0L=0x47;
 
 // USART1 initialization
 // Communication Parameters: 8 Data, 1 Stop, No Parity
 // USART1 Receiver: On
 // USART1 Transmitter: On
 // USART1 Mode: Asynchronous
 // USART1 Baud Rate: 9600
 UCSR1A=0x00;
 UCSR1B=0x98;
 UCSR1C=0x06;
 UBRR1H=0x00;
 UBRR1L=0x47;
  
 // Analog Comparator initialization
 // Analog Comparator: Off
 // Analog Comparator Input Capture by Timer/Counter 1: Off
 ACSR=0x80;
 SFIOR=0x00;

 // ADC initialization
 // ADC Clock frequency: 86,400 kHz
 // ADC Voltage Reference: Int., cap. on AREF
 ADMUX=ADC_VREF_TYPE & 0xff;
 ADCSRA=0x87; 
}

unsigned int K_BY_KOEFFICIENTS_REAL(unsigned int M)
{
unsigned long F,W,K;
//WEIGHT_NULL=6679, LOADCELL_NULL=618, DELTA_WEIGHT10KG=748, DELTA_LOADCELL10KG=772
if(M<LOADCELL_NULL)
 return 0;

F=((M-(unsigned long)LOADCELL_NULL)*1000)/((unsigned long)DELTA_LOADCELL10KG);
W=(unsigned long)WEIGHT_NULL-((unsigned long)DELTA_WEIGHT10KG*F)/1000;
if(W>0)
 K=((F*1000)/W) - 28; //frCoef -
else
 K=1800;

if(K>1800)
 K=1800; 
return K;
}

unsigned int K_BY_KOEFFICIENTS_ASFT(unsigned int M)
{
 long F,W,K;
//WEIGHT_NULL=6679, LOADCELL_NULL=618, DELTA_WEIGHT10KG=748, DELTA_LOADCELL10KG=772
 
 F=(long)M-LOADCELL_NULL;
 if(F<0)
  F=0;
  F=(F*1000)/DELTA_LOADCELL10KG;
 W=WEIGHT_NULL;
 K=(F*1000)/W;

if(K>3000)
 K=3000;  
  
 if(K>100)
  K=1000000/(1000000/(unsigned long)K+430-637); 
 return K; 
}



void led_zero(void)
{
    PORTB.6 = 1;
    #asm("nop");
    PORTB.6 = 0;
    #asm("nop");
    #asm("nop");
    #asm("nop");
}

void led_one(void)
{
    PORTB.6 = 1;
    #asm("nop");
    #asm("nop");
    #asm("nop");
    #asm("nop");
    PORTB.6 = 0; 
}

void lights(char G, char R, char B)
{
    unsigned char i;
    for(i = 0b10000000; i >= 0b00000001; i = i >> 1)
    {
        if((G & i) > 0)
            led_one();
        else
            led_zero();            
    } 
     
    for(i = 0b10000000; i >= 0b00000001; i = i >> 1)
    {
        if((R & i) > 0)
            led_one();
        else
            led_zero();            
    }  
    
    for(i = 0b10000000; i >= 0b00000001; i = i >> 1)
    {
        if((B & i) > 0)
            led_one();
        else
            led_zero();            
    }
}

void Read_Setup_Calibr(void)
{

//unsigned char CALIBR_MAS[10]={249,66,94,7,9,7,2,8,24,(66+94+7+9+7+2+8+24)/8};
 //unsigned int WEIGHT_NULL=6694, LOADCELL_NULL=709, DELTA_WEIGHT10KG=702, DELTA_LOADCELL10KG=824;
 ZADANIE_S=SETUP_MAS[3];  
 R_IK=SETUP_MAS[1];                 
 R_TK=SETUP_MAS[2]+200;
  
 #ifdef FIXWEIGHT                                                                        
 WEIGHT_NULL=(unsigned int)DEFAULT_CALIBR_MAS[1]*100+(unsigned int)DEFAULT_CALIBR_MAS[2];
 #else
 WEIGHT_NULL=(unsigned int)CALIBR_MAS[1]*100+(unsigned int)CALIBR_MAS[2];
 #endif
 
 LOADCELL_NULL=(unsigned int)CALIBR_MAS[3]*100+(unsigned int)CALIBR_MAS[4];
 DELTA_WEIGHT10KG=(unsigned int)CALIBR_MAS[5]*100+(unsigned int)CALIBR_MAS[6];  
 DELTA_LOADCELL10KG=(unsigned int)CALIBR_MAS[7]*100+(unsigned int)CALIBR_MAS[8]; 
}

void Control_Sum_Send(void)
{
 unsigned char tmp=0;
 unsigned int S=0;
 
 for(tmp=1;tmp<25;tmp++)
  S=S+SEND_MAS[tmp];
  SEND_MAS[25]=S/24;  
}

void Control_Sum_Calibr(void)
{
 unsigned char tmp=0;
 unsigned int S=0;
 
 for(tmp=1;tmp<9;tmp++)
  S=S+CALIBR_MAS[tmp];
 CALIBR_MAS[9]=S/8;  
}


void Control_Sum_Setup(void)
{
 unsigned char tmp=0;
 unsigned int S=0;
 
 for(tmp=1;tmp<7;tmp++)
  S=S+SETUP_MAS[tmp];
 SETUP_MAS[7]=S/6;  
}

// Timer 1 overflow interrupt service routine
interrupt [TIM1_OVF] void timer1_ovf_isr(void)
{
if(ovf_IK<2)
 {
  ovf_IK++;  
 }
if(ovf_TK<2)
 {
  ovf_TK++; 
 }
}
//***********************************************************************************************************
//***********************************************************************************************************
//***********************************************************************************************************




void delay(unsigned int d)
{              
 unsigned int y;
 for(y=0;y<d;y++)
 {}
}



void SPI_MasterInit(void)
{
// DDRB.1=1; //SCK
// PORTB.1=0; 
// DDRB.2=1; //MOSI
// PORTB.2=1;
// DDRB.3=0; //MISO
// PORTB.3=0;

 DDRB |= (1 << 0) | (1 << 1) | (1 << 2); //SS, SCK, MOSI - out
 DDRB &= ~(1 << 3); //MISO - in
 SPCR = (1<<SPE) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPR0);
}


unsigned char SPI_MasterReceive(void)
{
//unsigned char t,x=0;
//
// for(t=128;t>=1;t=t/2)         
// { 
//  PORTB.1=1; 
//  delay(100);    
//  PORTB.1=0;
//  if(!PINB.3)    
//    x=x+t; 
//  delay(100);                                        
// }       
// return x;
 
 SPI_MasterTransmit(0xFF);
 while(!(SPSR & (1<<SPIF)))
  continue;
 return SPDR;
}


void SPI_MasterTransmit(unsigned char x)
{
//unsigned char t;
//
// for(t=128;t>=1;t=t/2)         
// {
// PORTB.1=1; 
// delay(200);
// if(x&t)
//  PORTB.2=0; 
// else       
//  PORTB.2=1; 
// delay(200);                    
// PORTB.1=0;
// delay(200);                    
// } 
// PORTB.2=1;
// delay(300);
 
 SPDR = x;
 while(!(SPSR & (1<<SPIF)))
  continue;
}



void SET_AD7799(void)
{
 delay_ms(100);
 SPI_MasterTransmit(0b11111111);
 SPI_MasterTransmit(0b11111111);
 SPI_MasterTransmit(0b11111111);
 SPI_MasterTransmit(0b11111111); 
 delay_ms(100);
 SPI_MasterTransmit(0x10);    //conf
 delay(10000);                                       
 //#ifdef ADC_TO_KG
 //SPI_MasterTransmit(0b00000111); //bipolar and *128
 //#else
 SPI_MasterTransmit(0b00010111); //unipolar and *128
 //#endif
 SPI_MasterTransmit(0b00010000);
 delay(10000);
                
     
 SPI_MasterTransmit(0x08);  //mode
 delay(10000);
 SPI_MasterTransmit(0b00000000);
 //SPI_MasterTransmit(0b00001111);
 
 SPI_MasterTransmit(0b00001100);//10Hz
 //SPI_MasterTransmit(0b00001000);//20Hz
 delay(10000);
 SPI_MasterTransmit(0x5C);
 delay(10000);  
}

 unsigned int READ_AD7799(void)
{
 unsigned char a1,a2;
 unsigned int M;  
        delay(100);
        a1=SPI_MasterReceive();
        a2=SPI_MasterReceive();
        SPI_MasterReceive(); 
        M=(unsigned int)a1*256+(unsigned int)a2;
        return M;
        //return a2;
}


void uart1SendByte(char data)
{
    while(!( UCSR1A & (1 << UDRE)));
    UDR1 = data;
}

void uart1SendString(char *str)
{
    while(*str)
    {
        uart1SendByte(*str++);
    }
}

void uart1SendArray(unsigned char *array, unsigned char size)
{
   unsigned char i;
    for(i = 0; i < size; ++i)
    {
        uart1SendByte(array[i]);
    }
}

// USART0 Receiver interrupt service routine
interrupt [USART0_RXC] void usart0_rx_isr(void)
{
char simvol;
simvol=UDR0;
    
     if(simvol=='P')
   {
    GPS_flag_gp=1;
    GPS_zap_counter=0;
    goto exit_int;
   }
    if(GPS_flag_gp==1)
   {
    GPS_string_name[0]=simvol;
    GPS_flag_gp=2;
    goto exit_int;
   }
    if(GPS_flag_gp==2)
   {
    GPS_string_name[1]=simvol;
    GPS_flag_gp=3;
    goto exit_int;
   }
    if(GPS_flag_gp==3)
   {
    GPS_string_name[2]=simvol;
    if(GPS_string_name[0]=='G'&&GPS_string_name[1]=='G'&&GPS_string_name[2]=='A')
      {GPS_flag_gp=4;
       GPS_flag_ready=0;
       }
    else
     GPS_flag_gp=0;   
    goto exit_int;
   }
      
    if((GPS_flag_gp==4)&&(simvol==','))
    {
     GPS_zap_counter++;
     GPS_sim_counter=0;
     goto exit_int;
    }


   if(GPS_flag_gp==4)
   {
    
    if(GPS_zap_counter==2)//shir
    {
     switch(GPS_sim_counter)
     {
      case 0:
       GPS_shir[0]=(simvol-48)*10;
      break;
      case 1:
       GPS_shir[0]=GPS_shir[0]+(simvol-48);
      break;
      case 2:
       GPS_shir[1]=(simvol-48)*10;
      break;
      case 3:
       GPS_shir[1]=GPS_shir[1]+(simvol-48);
      break;
      case 5:
       GPS_shir[2]=(simvol-48)*1000;
      break;
      case 6:
       GPS_shir[2]=GPS_shir[2]+(simvol-48)*100;
      break;
      case 7:
       GPS_shir[2]=GPS_shir[2]+(simvol-48)*10;
      break;
      case 8:
       GPS_shir[2]=GPS_shir[2]+(simvol-48);
     }
     GPS_sim_counter++;
     
     goto exit_int;
    }
   if(GPS_zap_counter==3)
    {GPS_shir[3]=simvol;
     goto exit_int;}
   if(GPS_zap_counter==4)//dolg
    {
     switch(GPS_sim_counter)
     {
      case 0:
    GPS_dolg[0]=(simvol-48)*100;
      break;
      case 1:
    GPS_dolg[0]=GPS_dolg[0]+(simvol-48)*10;
      break;
      case 2:
    GPS_dolg[0]=GPS_dolg[0]+(simvol-48);
      break;
      case 3:
       GPS_dolg[1]=(simvol-48)*10;
      break;
      case 4:
       GPS_dolg[1]=GPS_dolg[1]+(simvol-48);
      break;
      case 6:
       GPS_dolg[2]=(simvol-48)*1000;
      break;
      case 7:
       GPS_dolg[2]=GPS_dolg[2]+(simvol-48)*100;
      break;
      case 8:
       GPS_dolg[2]=GPS_dolg[2]+(simvol-48)*10;
      break;
      case 9:
       GPS_dolg[2]=GPS_dolg[2]+(simvol-48);
     }
     GPS_sim_counter++;
     goto exit_int;
    }
   if(GPS_zap_counter==5)
    {
     GPS_dolg[3]=simvol;
     goto exit_int;     
    }
    if(GPS_zap_counter==6)
    {
     GPS_solve=simvol;
     GPS_flag_ready=1;
     GPS_flag_gp=0; 
     GPS_zap_counter=0;  
     GPS_ON_COUNTER=0; 
     
      SEND_MAS[12]=1;
     
     SEND_MAS[13]=(unsigned char)GPS_shir[0];
     SEND_MAS[14]=(unsigned char)GPS_shir[1];
     SEND_MAS[15]=(unsigned char)(GPS_shir[2]/100);
     SEND_MAS[16]=(unsigned char)(GPS_shir[2]%100);
     
     SEND_MAS[17]=(unsigned char)GPS_dolg[0];
     SEND_MAS[18]=(unsigned char)GPS_dolg[1];
     SEND_MAS[19]=(unsigned char)(GPS_dolg[2]/100);
     SEND_MAS[20]=(unsigned char)(GPS_dolg[2]%100);
     
     SEND_MAS[21]=(unsigned char)GPS_shir[3];
     SEND_MAS[22]=(unsigned char)GPS_dolg[3];
        
    }
  }
       
 
 exit_int:
}

     
// USART1 Receiver interrupt service routine
interrupt [USART1_RXC] void usart1_rx_isr(void)
{
 char data;
  data=UDR1;
 if((receive_counter==0)||(data>245))
 {                     
  receive_counter=0;
  switch(data)
  {          
   //setup request
   case 246:
   flag_transmission=248;
   break;   
   
   //calibr request
   case 247:
   flag_transmission=249;   
   break;
   
   //setup table
   case 248:
   flag_receive=248;
   receive_counter=7;
   break;
      
   //calibr table
   case 249:
   flag_receive=249;
   receive_counter=9;
   break;       
   
    //system on   
   case 250:      
    if(flag_I_NULL<10)//If the current null calibration has not finished
     break;
    flag_start=1;       
   break;      
   
   //system off
   case 251:
   flag_start=0;  
   break; 
    
   case 252:
   PORTC.1 = 1;//fonar on   
   break;
   
   case 253:
   PORTC.1 = 0;//fonar off 
   break;
  }
 }
 else
 {                     
   if(flag_receive==248)
   {
    SETUP_MAS[8-receive_counter]=data;
    if(receive_counter==1)
    {
     save_to_eeprom();
     Read_Setup_Calibr();
    } 
   }  
   
    if(flag_receive==249)
    {
     CALIBR_MAS[10-receive_counter]=data;
     if(receive_counter==1)
     {
      save_to_eeprom();
      Read_Setup_Calibr();
     }
    }      
       
   receive_counter--;
 } 
}





// Read the AD conversion result
unsigned int read_adc(unsigned char adc_input)
{
 ADMUX=adc_input | (ADC_VREF_TYPE & 0xff);
 // Delay needed for the stabilization of the ADC input voltage
 delay_us(7); 
 // Start the AD conversion
 ADCSRA|=0x40;
 // Wait for the AD conversion to complete
 while ((ADCSRA & 0x10)==0);
  ADCSRA|=0x10;
 return ADCW;
}


 
 unsigned char NEW_REGULATOR(unsigned int Z,unsigned int S)//s 1000=1
 {
  int U,E;
   
  E=150-S;//z always 150
  PID_I_S=PID_I_S+E;
  if(PID_I_S>1000)
   PID_I_S=1000;
  if(PID_I_S<0)
   PID_I_S=0;
   
   if(S<30)
    PID_I_S=800;
      
   U=PID_I_S;
      
   
 U=U/4; 
  if(U<0)
   U=0;
  if(U>255)
   U=255;
  return (unsigned char)U;
 }
  
 
// Timer2 overflow interrupt service routine
////100HZ Program cycle
interrupt [TIM2_OVF] void timer2_ovf_isr(void)
{
 int SCOLGENIE=0;
 unsigned char PWM=0;             

 TCNT2=148;//100HZ
 //Speed---------------------------------------------------------------------------
  if((IK_DELTA>400)&&(ovf_IK<2))   //   ~~160km/h             172,800 kHz
          {
           IK_SPEED_KM_H=(unsigned int)(((unsigned long)R_IK*2255)/IK_DELTA); 
          }
  else
          {
           IK_SPEED_KM_H=0;
          }                             
          IK_SPEED_MAS[0]=IK_SPEED_MAS[1];
          IK_SPEED_MAS[1]=IK_SPEED_MAS[2];
          IK_SPEED_MAS[2]=IK_SPEED_KM_H;
          
  if((TK_DELTA>400)&&(ovf_TK<2))   //   ~~160            172,800 kHz
          {
           TK_SPEED_KM_H=(unsigned int)(((unsigned long)R_TK*2171)/TK_DELTA);
          }
  else
          {
           TK_SPEED_KM_H=0;
          }             
          TK_SPEED_MAS[0]=TK_SPEED_MAS[1];
          TK_SPEED_MAS[1]=TK_SPEED_MAS[2];
          TK_SPEED_MAS[2]=TK_SPEED_KM_H;
  //Speed---------------------------------------------------------------------------
  
  
        //Proverka u vichiclenie skolgenia---------------------------------------------------------------
          if((IK_SPEED_KM_H>=TK_SPEED_KM_H)||(TK_SPEED_KM_H<100))// 10kmh
            SCOLGENIE=0;
          else
            SCOLGENIE=(int)((((long int)(TK_SPEED_KM_H-IK_SPEED_KM_H))*1000)/((long int)TK_SPEED_KM_H));
        //-----------------------------------------------------------------------------------------------
          
        
        if(flag_start==1)
          { 
           if(TK_SPEED_KM_H<750)
           {            
              PWM=NEW_REGULATOR(ZADANIE_S*10,(unsigned int)SCOLGENIE); 
           }
           else 
           {
            PWM=255;
            //PID_I_S=800;
           } 
          }
          else
          {
           PWM=0;
          }              
           OCR0=255-PWM;       
   
 if(program_cycle_counter<9)
  {program_cycle_counter++;}   
 else                  
  {
   program_cycle_flag=1;
   program_cycle_counter=0;
  }
}


//eeprom unsigned char EEP_CALIBR_MAS[10];
//eeprom unsigned char EEP_SETUP_MAS[8];

//unsigned char CALIBR_MAS[10]={249,66,94,7,9,7,2,8,24,(66+94+7+9+7+2+8+24)/8};
//unsigned char SETUP_MAS[8]={248,198,130,10,1,0,0,(198+130+10+1)/6};
void load_from_eeprom(void)
{
 unsigned char tmp;
 unsigned int cal_sum=0,setup_sum=0;
 
 CALIBR_MAS[0]=EEP_CALIBR_MAS[0];
 CALIBR_MAS[9]=EEP_CALIBR_MAS[9];        
  for(tmp=1;tmp<=8;tmp++)           
 {
   CALIBR_MAS[tmp]=EEP_CALIBR_MAS[tmp];
   cal_sum=cal_sum+CALIBR_MAS[tmp];
 }    
 cal_sum=cal_sum/8;       
   
   if((CALIBR_MAS[0]!=249)||(CALIBR_MAS[9]!=cal_sum))
 {  
  for(tmp=0;tmp<=9;tmp++)           
  {
   CALIBR_MAS[tmp]=DEFAULT_CALIBR_MAS[tmp];
  } 
 }
  
 SETUP_MAS[0]=EEP_SETUP_MAS[0];
 SETUP_MAS[7]=EEP_SETUP_MAS[7];
  for(tmp=1;tmp<=6;tmp++)           
 {
  SETUP_MAS[tmp]=EEP_SETUP_MAS[tmp];
  setup_sum=setup_sum+SETUP_MAS[tmp];
 }
   setup_sum=setup_sum/6;
   if((SETUP_MAS[0]!=248)||(SETUP_MAS[7]!=setup_sum))
  { 
    for(tmp=0;tmp<=7;tmp++)           
   {
    SETUP_MAS[tmp]=DEFAULT_SETUP_MAS[tmp];
   } 
 }   
}

void save_to_eeprom(void)
{
 unsigned char tmp;
 unsigned int sum;
  
  sum=0; 
  for(tmp=1;tmp<=8;tmp++)           
  {
   sum=sum+CALIBR_MAS[tmp];
  }        
  sum=sum/8;
  
  if(sum==CALIBR_MAS[9])
  {
   for(tmp=0;tmp<=9;tmp++)           
   {
    EEP_CALIBR_MAS[tmp]=CALIBR_MAS[tmp];
   }
  }
  
  sum=0; 
  for(tmp=1;tmp<=6;tmp++)           
  {
   sum=sum+SETUP_MAS[tmp];
  }        
  sum=sum/6;
  if(sum==SETUP_MAS[7])
  {
   for(tmp=0;tmp<=7;tmp++)           
   {
    EEP_SETUP_MAS[tmp]=SETUP_MAS[tmp];
   }
  }
  
}


//unsigned int K_BY_KOEFFICIENTS_OLD(unsigned int M)
//{
//unsigned long F,W,K;
////WEIGHT_NULL=6679, LOADCELL_NULL=618, DELTA_WEIGHT10KG=748, DELTA_LOADCELL10KG=772
//if(M<LOADCELL_NULL)
// return 0;
//
//F=((M-(unsigned long)LOADCELL_NULL)*1000)/((unsigned long)DELTA_LOADCELL10KG);
//W=(unsigned long)WEIGHT_NULL-((unsigned long)DELTA_WEIGHT10KG*F)/1000;
//if(W>0)
// K=(F*1000)/W;
//else
// K=3000;
//
//if(K>3000)
// K=3000; 
//return K; 
//}

